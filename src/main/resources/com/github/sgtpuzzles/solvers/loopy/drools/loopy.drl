package com.github.sgtpuzzles.solvers.loopy.drools

import java.util.List
import java.util.Set

import org.drools.core.spi.KnowledgeHelper

import com.github.sgtpuzzles.grid.model.Edge
import com.github.sgtpuzzles.solvers.loopy.LineStatus
import com.github.sgtpuzzles.solvers.loopy.Move

import function com.github.sgtpuzzles.solvers.loopy.drools.AtMost.atMost
import function com.github.sgtpuzzles.solvers.loopy.drools.AtLeast.atLeast

global org.slf4j.Logger log

// Rules that work based on EdgeSettings
rule "Remove set edge from SimpleEdgeRestriction"
when
	$es : EdgeSetting($edge: edge)
	$er : SimpleEdgeRestriction(edges contains $edge)
then
	modify($er) { recordSetting($es) }
	if ($er instanceof AtLeast && $er.getExpectedYeses() <= 0
		|| $er instanceof AtMost && $er.getExpectedNos() <= 0) {
		delete($er);
	}
end

rule "CountOrNone becomes count"
when
	$es : EdgeSetting($edge: edge, status == LineStatus.LINE_YES)
	$con: CountOrNone(edges contains $edge)
then
	convertToCount(drools, $con);
end

rule "CountOrNone remove unset edge"
when
	$es : EdgeSetting($edge: edge, status == LineStatus.LINE_NO)
	$con: CountOrNone(edges contains $edge)
then
	modify($con) { recordSetting($es) }
end

rule "Merge ContinuousLines"
when
	$es   : EdgeSetting($edge: edge, $v1: edge.vertex1, $v2: edge.vertex2, status == LineStatus.LINE_YES)
	$line : ContinuousLine(ends contains $v1)
	$line2: ContinuousLine(this != $line, ends contains $v2)
then
	modify($line) { mergeWith($line2, $edge) };
	delete($line2)
end

rule "Extend ContinuousLine"
when
	$es  : EdgeSetting($edge: edge, $v1: edge.vertex1, $v2: edge.vertex2, status == LineStatus.LINE_YES)
	$line: ContinuousLine(ends contains $v1 || ends contains $v2, edges not contains $edge)
	// not merging two lines
	not ContinuousLine(this != $line, ends contains $v1 || ends contains $v2)
then
	modify($line) { extendWith($edge) };
end

rule "Init ContinuousLine"
when
	$es  : EdgeSetting($edge: edge, $v1: edge.vertex1, $v2: edge.vertex2, status == LineStatus.LINE_YES)
	// no continuous line with the edge and no possibility to merge or extend a continuous line
	not ContinuousLine(edges contains $edge || ends contains $v1 || ends contains $v2)
then
	insert(new ContinuousLine($edge));
end
	

rule "Retract EdgeSetting and record Move"
when
	$es : EdgeSetting($edge: edge)
	// setting has been processed by all rules above
	not EdgeRestriction(edges contains $edge)
	(ContinuousLine(edges contains $edge)
		or EdgeSetting($es == this, status == LineStatus.LINE_NO))
	$fg1: ConnectedFacesGroup(faces contains $edge.face1)
	$fg2: ConnectedFacesGroup(faces contains $edge.face2)
then
	delete($es);
	insert(new Move($es.getEdge(), $es.getStatus()));
	if ($fg1 != $fg2 && $fg1 != $fg2.getOppositeGroup()) {
		if ($es.getStatus() == LineStatus.LINE_NO) {
			delete($fg2);
			if ($fg1.mergeWith($fg2)) {
				delete($fg2.getOppositeGroup());
			}
			update($fg1);
			if ($fg1.getOppositeGroup() != null) {
				update($fg1.getOppositeGroup());
			}
		} else {
			if ($fg2.getOppositeGroup() != null) {
				delete($fg2.getOppositeGroup());
			}
			if ($fg1.markAsOpposite($fg2)) {
				delete($fg2);
			}
			update($fg1);
			update($fg1.getOppositeGroup());
		}
	}
end

// Rules that infer EdgeSettings
rule "AtLeast requires all set"
when
	not EdgeSetting()
	$al : AtLeast(expectedYeses == edges.size(), $edges: edges)
then
	delete($al);
	$edges.forEach(e -> insert(new EdgeSetting((Edge) e, LineStatus.LINE_YES)));
end

rule "AtMost requires none set"
when
	not EdgeSetting()
	$am : AtMost(expectedYeses == 0, $edges: edges)
then
	delete($am);
	$edges.forEach(e -> insert(new EdgeSetting((Edge) e, LineStatus.LINE_NO)));
end

rule "Prevent closing isolated loop"
when
	not EdgeSetting()
	$edge: Edge($v1: vertex1, $v2: vertex2)
	not Move(edge == $edge)
	ContinuousLine(ends contains $v1, ends contains $v2)
	// this incidentally covers the case of remaining other ContinuousLines
	exists AtLeast(expectedYeses > 1 || expectedYeses > 0 && edges not contains $edge)
then
	insert(new EdgeSetting($edge, LineStatus.LINE_NO));
end

rule "Simple Impossible Face Edges"
when
	not EdgeSetting()
	$con: CountOrNone(allOrNone, $edges: edges, $yeses: expectedYeses)
	AtMost($atMostEdges: edges, $yeses > expectedYeses)
	not Edge(this memberOf $edges, this not memberOf $atMostEdges)
then
	convertToNone(drools, $con);
end

rule "Edge faces in opposite groups"
when
	not EdgeSetting()
	$edge: Edge($f1: face1, $f2: face2)
	not Move(edge == $edge)
	$fg1 : ConnectedFacesGroup(faces contains $f1)
	$fg2 : ConnectedFacesGroup(faces contains $f2, oppositeGroup == $fg1)
then
	insert(new EdgeSetting($edge, LineStatus.LINE_YES));
end

rule "Edge faces in same group"
when
	not EdgeSetting()
	$edge: Edge($f1: face1, $f2: face2)
	not Move(edge == $edge)
	$fg1 : ConnectedFacesGroup(faces contains $f1, faces contains $f2)
then
	insert(new EdgeSetting($edge, LineStatus.LINE_NO));
end

// Rules that infer other facts
rule "AtLeast overlaps mandatory CountOrNone"
when
	not EdgeSetting()
	$con: CountOrNone($edges: edges)
	AtLeast($atLeastEdges: edges, $atMostNos: expectedNos)
	// count common edges: can we satisfy AtLeast if we remove the CountOrNone?
	Set(size > $atMostNos)
		from collect (Edge(this memberOf $edges) from $atLeastEdges)
then
	convertToCount(drools, $con);
end

rule "CountOrNone becomes none"
when
	$con: CountOrNone($edges: edges, edges.size < expectedYeses)
then
	convertToNone(drools, $con);
end

rule "AtMost overlaps AtLeast with more edges than its expected yeses"
when
	not EdgeSetting()
	$am: AtMost($edgesA: edges, $amYeses: expectedYeses > 0)
	$al: AtLeast(
		$edgesB: edges,
		$alYeses: expectedYeses > $amYeses
	)
	exists Edge(this memberOf $edgesA, this memberOf $edgesB)
	exists Edge(this memberOf $edgesA, this not memberOf $edgesB)
	exists Edge(this memberOf $edgesB, this not memberOf $edgesA)
	$commonEdges: Set(size > $amYeses) from collect (Edge(this memberOf $edgesA) from $edgesB)
then
	insert(atMost($amYeses).amongEdges($commonEdges));
end

rule "AtLeast overlaps AtMost with more edges than its expected nos"
when
	not EdgeSetting()
	$am: AtMost($edgesA: edges, $amYeses: expectedYeses, expectedYeses > 0)
	$al: AtLeast(
		$edgesB: edges,
		$alYeses: expectedYeses,
		$alNos: expectedNos > 0
	)
	exists Edge(this memberOf $edgesA, this memberOf $edgesB)
	exists Edge(this memberOf $edgesA, this not memberOf $edgesB)
	exists Edge(this memberOf $edgesB, this not memberOf $edgesA)
	$commonEdges: Set(size > $alNos) from collect (Edge(this memberOf $edgesA) from $edgesB)
then
	insert(atLeast($commonEdges.size() - $alNos).amongEdges($commonEdges));
end

rule "AtLeast contains AtMost"
when
	not EdgeSetting()
	$am: AtMost($edgesA: edges, $amYeses: expectedYeses, expectedYeses > 0)
	$al: AtLeast(
		$edgesB: edges,
		$alYeses: expectedYeses > $amYeses,
		edges.size > $edgesA.size
	)
	// all edges of the AtMost are within the AtLeast
	not Edge(this memberOf $edgesA, this not memberOf $edgesB)
	$remainingEdges: Set() from collect (Edge(this not memberOf $edgesA) from $edgesB)
then
	insert(atLeast($alYeses - $amYeses).amongEdges($remainingEdges));
end

rule "AtMost contains AtLeast"
when
	not EdgeSetting()
	$am: AtMost($edgesA: edges, $amYeses: expectedYeses, expectedYeses > 0)
	$al: AtLeast(
		$edgesB: edges,
		$alYeses: expectedYeses > 0,
		edges.size < $edgesA.size,
		// remaining edges cannot all be yeses to still satisfsy both
		$edgesA.size - edges.size > $amYeses - expectedYeses
	)
	// all edges of the AtLeast are within the AtMost
	not Edge(this not memberOf $edgesA, this memberOf $edgesB)
	$remainingEdges: Set() from collect (Edge(this not memberOf $edgesB) from $edgesA)
then
	insert(atMost($amYeses - $alYeses).amongEdges($remainingEdges));
end

// functions
function void deleteCountOrNone(KnowledgeHelper drools, CountOrNone con) {
	drools.delete(con);
}

function void convertToCount(KnowledgeHelper drools, CountOrNone con) {
	deleteCountOrNone(drools, con);
	if (con.isAllOrNone()) {
		con.getEdges().forEach(e -> drools.insert(new EdgeSetting(e, LineStatus.LINE_YES)));
	} else {
		drools.insert(con.toAtLeast());
		drools.insert(con.toAtMost());
	}
}

function void convertToNone(KnowledgeHelper drools, CountOrNone con) {
	deleteCountOrNone(drools, con);
	con.getEdges().forEach(e -> drools.insert(new EdgeSetting(e, LineStatus.LINE_NO)));
}

// queries
query getMoves ()
	$move: Move()
end